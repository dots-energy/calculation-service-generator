#  This work is based on original code developed and copyrighted by TNO 2023.
#  Subsequent contributions are licensed to you by the developers of such code and are
#  made available to the Project under one or several contributor license agreements.
#
#  This work is licensed to you under the Apache License, Version 2.0.
#  You may obtain a copy of the license at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Contributors:
#      TNO         - Initial implementation
#  Manager:
#      TNO

{%- import 'jinja2-templates/start_test_simulation.jinja2' as start_test_simulation_j2 %}
import os
import time
import threading
import typing
from datetime import datetime, timedelta
from base64 import b64encode
from paho.mqtt.client import Client
from dotenv import load_dotenv

from model.calculation.influxdb_connector import InfluxDBConnector
from model.calculation import esdl_parser
from model.io.io_data import *
import esdl
from test_local import test_esdl

load_dotenv()

calculation_services: typing.List[dict] = []
# names of calculation services to receive data from (as specified in the code generator yaml settings file)
receive_services_names = {{start_test_simulation_j2.receive_services_names(cookiecutter)}}
# ====================  START AUTO-CREATE TEST ESDL  ====================
# A test esdl file will be created which is not very realistic, just enough to run a test. For instance, this esdl file
# will assume a 'PV Panel' asset for this service, and 'example_assets' (see below) for 'receive' services.
# Alternatively, use your own esdl file in the section below.

# The model parameters (this will be sent by the Simulation Orchestrator with values from the ESDL file)
example_receive_esdl_type_names: typing.List[str] = [
        esdl.PVPark.__name__,
        esdl.SolarCollector.__name__,
        esdl.WindTurbine.__name__,
        esdl.WindPark.__name__,
        esdl.GeothermalSource.__name__,
        esdl.SourceProducer.__name__,
        esdl.ResidualHeatSource.__name__,
        esdl.WaterToPower.__name__,
        esdl.ElectricityNetwork.__name__,
        esdl.EConnection.__name__,
    ]

i_service = 0
for service_name in receive_services_names:
    calculation_services.append({
        'esdl_type': example_receive_esdl_type_names[i_service],
        'calc_service_name': service_name,
        'service_image_url': 'url_not_used_for_local_test'
    })
    i_service += 1

test_esdl_file_path = "test_file.esdl"
esdl_id = "esdl_id_1"
test_esdl.create_test_esdl_file(test_esdl_file_path, esdl_id, example_receive_esdl_type_names)

esdl_ids = [esdl_id]
# ====================  END AUTO-CREATE TEST ESDL  ====================

# ====================  START MANUAL ESDL  ====================
# # When using your own esdl file the AUTO-CREATE TEST ESDL section above can be commented out.
#
# test_esdl_file_path = '<esdl_file_path>'
#
# # specify ESDL type names for each calc service, as in 'receive_services_names' above (from service config yaml file)
{{-start_test_simulation_j2.append_manual_esdl_calc_services(cookiecutter)}}
#
# # specify ESDL object id's which the current service is to perform calculations for (as in the 'test_esdl_file_path')
# esdl_ids = ['esdl_id_1', 'esdl_id_2']
# ====================  END MANUAL ESDL  ====================

# ====================  START DATA AND SIMULATION SETTINGS  ====================
# Autogenerated mock input data, adjust for a more realistic scenario
simulation_name = 'test simulation'
new_step_dict = {}
# the 'esdl_id' should be the id of the origin ESDL object sending the data, this will be fixed below
esdl_id = 'origin_esdl_object_id_will_be_filled_in_later'
mock_input_data: dict[str, IODataInterface] = {
{{- start_test_simulation_j2.initialize_input_data_classes(cookiecutter) }}
}

# delay between sending of mock data objects
seconds_between_sends = 1

# Calculation time steps settings:
start_date = datetime(2023, 1, 1)
time_step_seconds = 3600
nr_of_time_steps = 3

# ====================  END DATA AND SIMULATION SETTINGS  ====================


# Start of the test simulation
sim_step_index = 0

with open(test_esdl_file_path, "rb") as esdl_file:
    esdl_base64string = b64encode(esdl_file.read()).decode("utf-8")

# per ESDL object:
#     a dictionary with, per calculation service, a list of connected ESDL objects
connected_input_esdl_objects_dict = {}
for esdl_id in esdl_ids:
    connected_input_esdl_objects_dict[esdl_id] = esdl_parser.get_connected_input_esdl_objects(esdl_id,
                                                                                              calculation_services,
                                                                                              esdl_base64string)
# expected ESDL objects (id's), per calculation service providing input
expected_esdl_ids_dict = {}
for _, connected_input_esdl_objects in connected_input_esdl_objects_dict.items():
    for service_name, connected_esdl_ids in connected_input_esdl_objects.items():
        for connected_esdl_id in connected_esdl_ids:
            if service_name not in expected_esdl_ids_dict:
                expected_esdl_ids_dict[service_name] = [connected_esdl_id]
            elif connected_esdl_id not in expected_esdl_ids_dict[service_name]:
                expected_esdl_ids_dict[service_name].append(connected_esdl_id)

def on_connect(client, userdata, flags, rc):
    # print("Connected with result code " + str(rc))
    pass


def on_message(client, userdata, msg):
    threading.Thread(target=process_message, args=[msg]).start()


simulation_id = os.getenv('SIMULATION_ID')
model_id = os.getenv('MODEL_ID')

influxdb_client: InfluxDBConnector = InfluxDBConnector(os.getenv('INFLUXDB_HOST'), os.getenv('INFLUXDB_PORT'),
                                                       os.getenv('INFLUXDB_USER'), os.getenv('INFLUXDB_PASSWORD'),
                                                       os.getenv('INFLUXDB_NAME'))
influxdb_client.create_database()

mqtt_client = Client(clean_session=True)
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message

mqtt_client.username_pw_set(os.getenv('MQTT_USERNAME'), os.getenv('MQTT_PASSWORD'))
mqtt_client.connect('localhost', port=int(os.getenv('MQTT_PORT')))


def test_simulation_orchestrator():
    mqtt_client.subscribe(f"/lifecycle/model/mso/{simulation_id}/{model_id}/ReadyForProcessing")
    mqtt_client.subscribe(f"/lifecycle/model/dots-so/{simulation_id}/{model_id}/Parameterized")
    mqtt_client.subscribe(f"/lifecycle/model/dots-so/{simulation_id}/{model_id}/CalculationsDone")
    mqtt_client.subscribe(f"/log/model/dots-so/{simulation_id}/{model_id}/#")

    print('Waiting for model service to be ready...')
    mqtt_client.loop_forever()


def process_message(msg):
    topic = msg.topic
    print(" [received] {}: {}".format(topic, msg.payload.decode('utf-8')))

    if topic == f"/lifecycle/model/mso/{simulation_id}/{model_id}/ReadyForProcessing":
        model_parameters_message = messages.ModelParameters(
            parameters_dict=json.dumps({
                'simulation_name': simulation_name,
                'start_timestamp': datetime.timestamp(start_date),
                'time_step_seconds': time_step_seconds,
                'nr_of_time_steps': nr_of_time_steps,
                'esdl_ids': esdl_ids,
                'calculation_services': calculation_services,
                'esdl_base64string': esdl_base64string,
            })
        )
        time.sleep(seconds_between_sends)
        send_output(f"/lifecycle/dots-so/model/{simulation_id}/{model_id}/ModelParameters",
                    model_parameters_message.SerializeToString())

    if topic == f"/lifecycle/model/dots-so/{simulation_id}/{model_id}/Parameterized":
        start_new_step()

    if topic == f"/lifecycle/model/dots-so/{simulation_id}/{model_id}/CalculationsDone":
        start_new_step()


def start_new_step():
    global sim_step_index
    global model_id

    sim_step_index += 1
    if sim_step_index > nr_of_time_steps:
        sim_step_index = 0
        send_output(f"/lifecycle/dots-so/model/{simulation_id}/{model_id}/SimulationDone", b"")
    else:
        print(f"Calculating time step {sim_step_index} (of {nr_of_time_steps})...")
        # the 'NewStep' will be sent by the Simulation Orchestrator at the start of each time step
        new_step_dict["time_step_nr"] = str(sim_step_index)
        new_step_dict["start_time_stamp"] = (start_date +
                                             timedelta(0, (sim_step_index + 1) * time_step_seconds)).timestamp()

        new_step_message = messages.NewStep(parameters_dict=json.dumps(new_step_dict))
        time.sleep(seconds_between_sends)
        send_output(f"/lifecycle/dots-so/model/{simulation_id}/{model_id}/NewStep",
                    new_step_message.SerializeToString())

        # the mock data below mimics data coming from other services in the simulation model
{{- start_test_simulation_j2.send_default_input_data_classes(cookiecutter)}}

def send_data(output_data: IODataInterface, esdl_id: EsdlId):
    output_data.origin_esdl_id = esdl_id
    topic = f"{output_data.get_main_topic()}/{simulation_id}/{esdl_id}/{output_data.get_name()}"
    send_output(topic, output_data.get_values_as_serialized_protobuf())


def send_output(topic: str, payload: bytes):
    mqtt_client.publish(topic, payload)
    print(f' [sent] {topic}')


if __name__ == '__main__':
    test_simulation_orchestrator()
